#!/usr/bin/python
# encoding=UTF-8

# Copyright Â© 2008
#   Piotr Lewandowski <piotr.lewandowski+sinntp@gmail.com>,
#   Jakub Wilk <ubanus@users.sf.net>.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License, version 2, as 
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.

__author__ = ('Jakub Wilk', 'Piotr Lewandowski')
__version__ = '0.100'

from nntplib import NNTP, NNTPTemporaryError
import errno
import logging
import logging.handlers
import mailbox
import optparse
import os
import os.path
import socket
import sys

def monkey_patch_mailbox_module():
    '''
    Work-around a bug in the `mailbox` module.
    See http://bugs.python.org/issue3228 for details.
    '''
    try:
        create_carefully = mailbox._create_carefully
    except AttributeError:
        return
    def create_carefully_666(*args, **kwargs):
        file = create_carefully(*args, **kwargs)
        mode = os.stat(file.name).st_mode & 0666
        os.chmod(file.name, mode)
        return file
    mailbox._create_carefully = create_carefully_666
monkey_patch_mailbox_module()
del monkey_patch_mailbox_module

class Config(object):

    def __init__(self, hostname):
        self._hostname = hostname
        self._root = os.getenv('SINNTP_HOME') or os.path.expanduser('~/.sinntp/')
        if not os.path.isdir(self._root):
            logging.info('Creating directory %r.', self._root)
            os.makedirs(self._root)

    def _get_file_name(self, name):
        base_name = '%s@%s' % (name, self._hostname)
        return os.path.join(self._root, base_name)

    def __getitem__(self, name):
        try:
            file = open(self._get_file_name(name), 'rb')
        except IOError, ex:
            if ex.errno == errno.ENOENT:
                return 0
            raise
        try:
            return int(file.read())
        finally:
            file.close()

    def __setitem__(self, name, value):
        file = open(self._get_file_name(name), 'wb')
        try:
            file.write(str(value))
        finally:
            file.close()

class Connection(NNTP):
    def fetch(self, group_name, start = 0):
        logging.info('Looking for group %r.', group_name)
        response, count, first, last, name = self.group(group_name)
        count, first, last = (int(x) for x in (count, first, last))
        i = max(start, first)
        count = max(last - i + 1, 0)
        logging.info('%(count)s message%(plural)s to download.' % dict(
            count = count if count else 'no',
            plural = 's' if count != 1 else ''
        ))
        while i <= last:
            try:
                self.stat(str(i))
            except NNTPTemporaryError, e:
                i += 1
            else:
                break
        else:
            return
        no = str(i)
        while 1:
            _, _, _, body = self.article(no)
            yield int(no), body
            try:
                _, no, _ = self.next()
            except NNTPTemporaryError, ex:
                if ex.response.startswith('421'):
                    break
                raise

class Command(object):

    def get_option_parser(self):
        o = optparse.OptionParser(usage = self.__doc__.rstrip(), version = '%prog ' + __version__)
        o.add_option('-s', '--syslog', dest='syslog', action='store_true')
        o.add_option('-v', '--verbose', dest='verbose', action='store_true')
        o.add_option('-p', '--plugin', dest='plugins', action='append')
        return o

    def __init__(self, argv):
        oparser = self.get_option_parser()
        self.options, self.args = oparser.parse_args(argv)
        self.oparser = oparser

    def __call__(self):
        pass

class Pull(Command):
    '''
    nntp-pull [options] groupname [groupname ...]
    '''

    NAME = 'pull'

    def get_option_parser(self):
        o = Command.get_option_parser(self)
        o.add_option('--limit', dest='limit', type='int', action='store')
        o.add_option('--reget', dest='reget', action='store_true')
        return o

    def __init__(self, argv):
        Command.__init__(self, argv)
        assert self.args.pop(0) == self.NAME
        if not self.args:
            self.oparser.error('At least one group name is required')
        self.groups = self.args
        del self.args

    def __call__(self, connection):
        config = Config(connection.host)
        for group in self.groups:
            mbox = None
            last = None
            start = config[group] if not self.options.reget else 0
            if self.options.limit is not None:
                _, _, _, last, _ = connection.group(group)
                last = int(last)
                start = max(start, last - self.options.limit + 1)
            try:
                for no, message in connection.fetch(group, start=start):
                    if not mbox:
                        mbox = mailbox.mbox(group, create = True)
                        mbox.lock()
                    last = no
                    message = '\n'.join(message)
                    mbox.add(message)
            finally:
                if mbox:
                    mbox.close()
            if last is not None:
                config[group] = last + 1

class Push(Command):
    '''
    nntp-push [options]
    '''

    NAME = 'push'

    def __init__(self, argv):
        oparser = Command.__init__(self, argv)
        assert self.args.pop(0) == self.NAME
        if self.args:
            self.oparser.error('No arguments are expected')

    def __call__(self, connection):
        connection.post(sys.stdin)

class BaseCommand(Command):

    COMMANDS = dict(
        pull = Pull,
        push = Push,
    )

    __doc__ = ''.join(command.__doc__.rstrip() for command in COMMANDS.itervalues())

    def get_option_parser(self):
        oparser = Command.get_option_parser(self)
        oparser.disable_interspersed_args()
        return oparser

    def __init__(self, argv):
        oparser = Command.__init__(self, argv)
        if not self.args:
            self.oparser.error('A command is expected')
        command_name = self.args[0]
        try:
            self.command_class = self.COMMANDS[command_name]
        except KeyError:
            self.oparser.error('Unknown command: %r.\n' % command_name)
        sys.argv[0] = 'nntp-%s' % command_name

def show_usage():
    sys.stderr.write('Usage: \n')
    for command in COMMANDS.itervalues():
        sys.stderr.write('    %s\n' % command.__doc__.strip())
    sys.exit(1)

def setup_logging(syslog, verbose):
    logger = logging.getLogger('')
    format = '%(message)s'
    if not syslog:
        handler = logging.StreamHandler()
    else:
        handler = logging.handlers.SysLogHandler('/dev/log')
        format = ''.join((sys.argv[0], '[%(process)d]: ', format))
    formatter = logging.Formatter(format, None)
    handler.setFormatter(formatter)
    logger.addHandler(handler)
    level = logging.INFO if not verbose else logging.DEBUG
    logger.setLevel(level)

if __name__ == '__main__':
    host = os.getenv('NNTPSERVER') or file('/etc/news/server').readline().strip()
    if not host:
        sys.stderr.write('NNTP server is not specified.\n')
        sys.exit(2)

    argv = sys.argv[:]
    argv0 = os.path.basename(argv.pop(0))
    if '-' in argv0:
        command_name = command.rsplit('-', 1)
        argv.insert(0, command_name)
    base_command = BaseCommand(argv)
    command = base_command.command_class(argv)
    setup_logging(command.options.syslog, command.options.verbose)
    try:
        logging.info('Connecting to %r...', host)
        connection = Connection(host)
    except socket.error, e:
        logging.error('Could not connect to %r: %s', host, e[1])
        sys.exit(3)
    try:
        command(connection)
    finally:
        connection.quit()
        logging.info('Connection to %r closed.', host)

# vim:ts=4 sw=4 et
