#!/usr/bin/python
# encoding=UTF-8

# Copyright Â© 2008
#   Piotr Lewandowski <piotr.lewandowski+sinntp@gmail.com>,
#   Jakub Wilk <ubanus@users.sf.net>.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License, version 2, as 
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.

__author__ = ('Jakub Wilk', 'Piotr Lewandowski')
__version__ = '0.100'

from nntplib import NNTP, NNTPTemporaryError, NNTPError
from cStringIO import StringIO
import email
import email.generator
import errno
import functools
import logging
import logging.handlers
import mailbox
import optparse
import os
import os.path
import socket
import sys

import plugins

def monkey_patch_mailbox_module():
    '''
    Work-around a bug in the `mailbox` module.
    See http://bugs.python.org/issue3228 for details.
    '''
    try:
        create_carefully = mailbox._create_carefully
    except AttributeError:
        return
    def create_carefully_666(*args, **kwargs):
        file = create_carefully(*args, **kwargs)
        mode = os.stat(file.name).st_mode & 0666
        os.chmod(file.name, mode)
        return file
    mailbox._create_carefully = create_carefully_666
monkey_patch_mailbox_module()
del monkey_patch_mailbox_module

class Config(object):

    def __init__(self, hostname):
        self._hostname = hostname
        self._root = os.getenv('SINNTP_HOME') or os.path.expanduser('~/.sinntp/')
        if not os.path.isdir(self._root):
            logging.info('Creating directory %r.', self._root)
            os.makedirs(self._root)

    def _get_file_name(self, name):
        base_name = '%s@%s' % (name, self._hostname)
        return os.path.join(self._root, base_name)

    def __getitem__(self, name):
        try:
            file = open(self._get_file_name(name), 'rb')
        except IOError, ex:
            if ex.errno == errno.ENOENT:
                return 0
            raise
        try:
            return int(file.read())
        finally:
            file.close()

    def __setitem__(self, name, value):
        file = open(self._get_file_name(name), 'wb')
        try:
            file.write(str(value))
        finally:
            file.close()

class Command(object):

    def get_option_parser(self):
        o = optparse.OptionParser(usage = self.__doc__.rstrip(), version = '%prog ' + __version__)
        o.add_option('-s', '--syslog', dest='syslog', action='store_true', help='use syslog for logging')
        o.add_option('-v', '--verbose', dest='verbose', action='store_true', help='be more verbose')
        o.add_option('-p', '--plugin', dest='plugins', action='append', metavar='PLUGIN', help='use plugin')
        o.add_option('-S', '--server', dest='server', action='store', help='specify server address')
        o.add_option('-U', '--username', dest='username', action='store', help='specify username')
        o.add_option('-P', '--password', dest='password', action='store', help='specify password')
        return o

    def __init__(self, argv):
        oparser = self.get_option_parser()
        self.options, self.args = oparser.parse_args(argv)
        self.plugins = []
        for spec in self.options.plugins or ():
            spec = spec.split(':')
            name = spec.pop(0)
            args = [arg for arg in spec if '=' not in arg]
            kwargs = dict(arg.split('=', 1) for arg in spec if '=' in arg)
            self.plugins += functools.partial(plugins.__dict__[name], *args, **kwargs),
        self.oparser = oparser

    def __call__(self):
        pass

class Pull(Command):
    '''
    nntp-pull [options] groupname[>filename] [groupname[>filename] ...]
    '''

    NAME = 'pull'

    def get_option_parser(self):
        o = Command.get_option_parser(self)
        o.add_option('--limit', dest='limit', type='int', action='store', metavar='N', help='pull at most N messages')
        o.add_option('--reget', dest='reget', action='store_true', help='start from the first available message')
        return o

    def __init__(self, argv):
        Command.__init__(self, argv)
        name = self.args.pop(0)
        assert name == self.NAME
        if not self.args:
            self.oparser.error('At least one group name is required')
        self.groups = self.args
        del self.args

    def fetch(self, connection, group_name, start):
        logging.info('Looking for group %r.', group_name)
        response, count, first, last, name = connection.group(group_name)
        count, first, last = (int(x) for x in (count, first, last))
        i = max(start, first)
        count = max(last - i + 1, 0)
        logging.info('%(count)s message%(plural)s to download.' % dict(
            count = count if count else 'No',
            plural = 's' if count != 1 else ''
        ))
        while i <= last:
            try:
                connection.stat(str(i))
            except NNTPTemporaryError, e:
                i += 1
            else:
                break
        else:
            return
        no = str(i)
        while 1:
            _, _, message_id, body = connection.article(no)
            logging.debug('Reading message %s.', message_id)
            yield int(no), body
            try:
                _, no, _ = connection.next()
            except NNTPTemporaryError, ex:
                if ex.response.startswith('421'):
                    break
                raise

    def __call__(self, connection):
        config = Config(connection.host)
        for group in self.groups:
            if '>' in group:
                group, mbox_name = group.split('>', 1)
            else:
                mbox_name = group
            mbox = None
            last = None
            start = config[group] if not self.options.reget else 0
            if self.options.limit is not None:
                _, _, _, end, _ = connection.group(group)
                start = max(start, int(end) - self.options.limit + 1)
            try:
                for no, message in self.fetch(connection, group, start):
                    if mbox is None:
                        mbox = mailbox.mbox(mbox_name, create=True)
                        mbox.lock()
                        stat = os.stat(mbox_name)
                        atime = stat.st_atime
                        mode = stat.st_mode
                    if not (message and message[-1].endswith('\n')):
                        message += ['']
                    message = '\n'.join(message)
                    message = email.message_from_string(message)
                    for plugin in self.plugins:
                        message = plugin(message = message)
                        if message is None:
                            break
                    if message is not None:
                        mbox.add(message)
                    last = no
            finally:
                if mbox is not None:
                    mbox.close()
                    mtime = os.stat(mbox_name).st_mtime
                    os.utime(mbox_name, (atime, mtime))
                    os.chmod(mbox_name, mode)
                if last is not None:
                    config[group] = last + 1

class Push(Command):
    '''
    nntp-push [options]
    '''

    NAME = 'push'

    def __init__(self, argv):
        oparser = Command.__init__(self, argv)
        name = self.args.pop(0)
        assert name == self.NAME

    def __call__(self, connection):
        message = email.message_from_file(sys.stdin)
        if self.args:
            message['Newsgroups'] = ','.join(self.args)
        for plugin in self.plugins:
            message = plugin(message = message)
        buffer = StringIO()
        generator = email.generator.Generator(buffer, mangle_from_=False)
        generator.flatten(message)
        buffer.seek(0)
        connection.post(buffer)

class BaseCommand(Command):

    COMMANDS = dict(
        pull = Pull,
        push = Push,
    )

    __doc__ = ''.join(command.__doc__.rstrip() for command in COMMANDS.itervalues())

    def get_option_parser(self):
        oparser = Command.get_option_parser(self)
        oparser.disable_interspersed_args()
        return oparser

    def __init__(self, argv):
        oparser = Command.__init__(self, argv)
        if not self.args:
            self.oparser.error('A command is expected')
        command_name = self.args[0]
        try:
            self.command_class = self.COMMANDS[command_name]
        except KeyError:
            self.oparser.error('Unknown command: %r.' % command_name)
        sys.argv[0] = 'nntp-%s' % command_name

def show_usage():
    sys.stderr.write('Usage: \n')
    for command in COMMANDS.itervalues():
        sys.stderr.write('    %s\n' % command.__doc__.strip())
    sys.exit(1)

def setup_logging(syslog, verbose):
    logger = logging.getLogger()
    format = '%(message)s'
    if not syslog:
        handler = logging.StreamHandler()
    else:
        handler = logging.handlers.SysLogHandler(
            '/dev/log',
            facility = logging.handlers.SysLogHandler.LOG_NEWS
        )
        format = ''.join((sys.argv[0], '[%(process)d]: ', format))
    formatter = logging.Formatter(format, None)
    handler.setFormatter(formatter)
    logger.addHandler(handler)
    level = logging.INFO if not verbose else logging.DEBUG
    logger.setLevel(level)

if __name__ == '__main__':
    argv = sys.argv[:]
    argv0 = os.path.basename(argv.pop(0))
    if '-' in argv0:
        [_, command_name] = argv0.rsplit('-', 1)
        argv.insert(0, command_name)
    base_command = BaseCommand(argv)
    command = base_command.command_class(argv)
    setup_logging(command.options.syslog, command.options.verbose)
    host = command.options.server or os.getenv('NNTPSERVER') or \
        (os.path.exists('/etc/news/server') and file('/etc/news/server').readline().strip())
    if not host:
        sys.stderr.write('NNTP server is not specified.\n')
        sys.exit(2)
    try:
        logging.info('Connecting to %r...', host)
        connection = NNTP(host, user = command.options.username, password = command.options.password)
    except socket.error, e:
        logging.error('Could not connect to %r: %s', host, e[1])
        sys.exit(3)
    try:
        command(connection)
    except NNTPError, e:
        logging.error('NNTP error: ' + e.message)
        sys.exit(4)
    finally:
        connection.quit()
        logging.info('Connection to %r closed.', host)

# vim:ts=4 sw=4 et
